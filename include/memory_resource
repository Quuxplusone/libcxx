// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_MEMORY_RESOURCE
#define _LIBCPP_MEMORY_RESOURCE

/**
    memory_resource synopsis

// C++17

namespace std {
namespace pmr {

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;

  // Pool resource classes
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace std

 */

#include <__config>
#include <__functional_base>
#include <__memory_resource_base>
#include <limits>
#include <memory>
#if !defined(_LIBCPP_HAS_NO_THREADS)
#include <mutex>
#endif
#include <new>
#include <stdexcept>
#include <tuple>
#include <type_traits>
#include <utility>
#include <cstddef>
#include <cstdlib>
#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

namespace pmr
{

// 23.12.4, mem.res.global

_LIBCPP_FUNC_VIS
memory_resource * new_delete_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * null_memory_resource() _NOEXCEPT;


// 23.12.5, mem.res.pool

// 23.12.5.2, mem.res.pool.options

struct pool_options {
    size_t max_blocks_per_chunk = 0;
    size_t largest_required_pool_block = 0;
};

// 23.12.5.1, mem.res.pool.overview

struct __pool_resource_chunk;

class _LIBCPP_TYPE_VIS unsynchronized_pool_resource : public memory_resource
{
public:
    unsynchronized_pool_resource(const pool_options& __opts, memory_resource* __upstream);

    _LIBCPP_INLINE_VISIBILITY
    unsynchronized_pool_resource()
        : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit unsynchronized_pool_resource(memory_resource* __upstream)
        : unsynchronized_pool_resource(pool_options(), __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit unsynchronized_pool_resource(const pool_options& __opts)
        : unsynchronized_pool_resource(__opts, get_default_resource()) {}

    unsynchronized_pool_resource(const unsynchronized_pool_resource&) = delete;

    virtual ~unsynchronized_pool_resource();

    unsynchronized_pool_resource& operator=(const unsynchronized_pool_resource&) = delete;

    void release();

    _LIBCPP_INLINE_VISIBILITY
    memory_resource* upstream_resource() const
        { return __res_; }

    _LIBCPP_INLINE_VISIBILITY
    pool_options options() const
        { return __options_; }

protected:
    void* do_allocate(size_t __bytes, size_t __align);

    void do_deallocate(void* __p, size_t __bytes, size_t __align);

    _LIBCPP_INLINE_VISIBILITY
    bool do_is_equal(const memory_resource& __other) const _NOEXCEPT
        { return this == _VSTD::addressof(__other); }

private:
    memory_resource *__res_;
    __pool_resource_chunk *__chunk_;
    pool_options __options_;
};

class _LIBCPP_TYPE_VIS synchronized_pool_resource : public memory_resource
{
public:
    synchronized_pool_resource(const pool_options& __opts, memory_resource* __upstream)
        : __unsync_(__opts, __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    synchronized_pool_resource()
        : synchronized_pool_resource(pool_options(), get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit synchronized_pool_resource(memory_resource* __upstream)
        : synchronized_pool_resource(pool_options(), __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit synchronized_pool_resource(const pool_options& __opts)
        : synchronized_pool_resource(__opts, get_default_resource()) {}

    synchronized_pool_resource(const synchronized_pool_resource&) = delete;

    virtual ~synchronized_pool_resource();

    synchronized_pool_resource& operator=(const synchronized_pool_resource&) = delete;

    void release() {
#if !defined(_LIBCPP_HAS_NO_THREADS)
        unique_lock<mutex> __lk(__mut_);
#endif
        __unsync_.release();
    }

    _LIBCPP_INLINE_VISIBILITY
    memory_resource* upstream_resource() const
        { return __unsync_.upstream_resource(); }

    _LIBCPP_INLINE_VISIBILITY
    pool_options options() const
        { return __unsync_.options(); }

protected:
    void* do_allocate(size_t __bytes, size_t __align) {
#if !defined(_LIBCPP_HAS_NO_THREADS)
        unique_lock<mutex> __lk(__mut_);
#endif
        return __unsync_.allocate(__bytes, __align);
    }

    void do_deallocate(void* __p, size_t __bytes, size_t __align) {
#if !defined(_LIBCPP_HAS_NO_THREADS)
        unique_lock<mutex> __lk(__mut_);
#endif
        return __unsync_.deallocate(__p, __bytes, __align);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool do_is_equal(const memory_resource& __other) const _NOEXCEPT
        { return this == _VSTD::addressof(__other); }

private:
#if !defined(_LIBCPP_HAS_NO_THREADS)
    mutex __mut_;
#endif
    unsynchronized_pool_resource __unsync_;
};

// 23.12.6, mem.res.monotonic.buffer

struct __monotonic_buffer_header {
    void *__start_;
    __monotonic_buffer_header *__next_;
    size_t __capacity_;
    size_t __alignment_;
    size_t __used_;
};

class _LIBCPP_TYPE_VIS monotonic_buffer_resource : public memory_resource
{
    static const size_t __default_buffer_capacity = 1024;
    static const size_t __default_buffer_alignment = 16;

public:
    _LIBCPP_INLINE_VISIBILITY
    explicit monotonic_buffer_resource(memory_resource* __upstream)
        : monotonic_buffer_resource(nullptr, __default_buffer_capacity, __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource(size_t __initial_size, memory_resource* __upstream)
        : monotonic_buffer_resource(nullptr, __initial_size, __upstream) {}

    monotonic_buffer_resource(void* __buffer, size_t __buffer_size, memory_resource* __upstream);

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource()
        : monotonic_buffer_resource(get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit monotonic_buffer_resource(size_t __initial_size)
        : monotonic_buffer_resource(__initial_size, get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource(void* __buffer, size_t __buffer_size)
        : monotonic_buffer_resource(__buffer, __buffer_size, get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;

    virtual ~monotonic_buffer_resource();

    monotonic_buffer_resource& operator=(const monotonic_buffer_resource&) = delete;

    void release();

    _LIBCPP_INLINE_VISIBILITY
    memory_resource* upstream_resource() const
        { return __res_; }

protected:
    void* do_allocate(size_t __bytes, size_t __alignment);

    _LIBCPP_INLINE_VISIBILITY
    void do_deallocate(void*, size_t, size_t)
        {}

    _LIBCPP_INLINE_VISIBILITY
    bool do_is_equal(const memory_resource& __other) const _NOEXCEPT
        { return this == _VSTD::addressof(__other); }

private:
    __monotonic_buffer_header __original_;
    memory_resource* __res_;
    size_t __next_buffer_size_;
};

} // namespace pmr

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif /* _LIBCPP_MEMORY_RESOURCE */
