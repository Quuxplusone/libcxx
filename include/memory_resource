// -*- C++ -*-
//===------------------------ memory_resource -----------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_MEMORY_RESOURCE
#define _LIBCPP_MEMORY_RESOURCE

/**
    memory_resource synopsis

// C++17

namespace std {
namespace pmr {

  class memory_resource;

  bool operator==(const memory_resource& a,
                  const memory_resource& b) noexcept;
  bool operator!=(const memory_resource& a,
                  const memory_resource& b) noexcept;

  template <class Tp> class polymorphic_allocator;

  template <class T1, class T2>
  bool operator==(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;
  template <class T1, class T2>
  bool operator!=(const polymorphic_allocator<T1>& a,
                  const polymorphic_allocator<T2>& b) noexcept;

  // Global memory resources
  memory_resource* new_delete_resource() noexcept;
  memory_resource* null_memory_resource() noexcept;
  memory_resource* set_default_resource(memory_resource* r) noexcept;
  memory_resource* get_default_resource() noexcept;

  // Pool resource classes
  struct pool_options;
  class synchronized_pool_resource;
  class unsynchronized_pool_resource;
  class monotonic_buffer_resource;

} // namespace pmr
} // namespace std

 */

#include <__config>
#include <__functional_base>
#include <limits>
#include <memory>
#if !defined(_LIBCPP_HAS_NO_THREADS)
#include <mutex>
#endif
#include <new>
#include <stdexcept>
#include <tuple>
#include <type_traits>
#include <utility>
#include <cstddef>
#include <cstdlib>
#include <__debug>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#pragma GCC system_header
#endif

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

namespace pmr
{

// 23.12.2, mem.res.class
class _LIBCPP_TYPE_VIS memory_resource
{
    static const size_t __max_align = alignof(max_align_t);

// 23.12.2.1, mem.res.public
public:
    virtual ~memory_resource() = default;

    _LIBCPP_INLINE_VISIBILITY
    void* allocate(size_t __bytes, size_t __align = __max_align)
        { return do_allocate(__bytes, __align); }

    _LIBCPP_INLINE_VISIBILITY
    void deallocate(void * __p, size_t __bytes, size_t __align = __max_align)
        { do_deallocate(__p, __bytes, __align); }

    _LIBCPP_INLINE_VISIBILITY
    bool is_equal(memory_resource const & __other) const _NOEXCEPT
        { return do_is_equal(__other); }

// 23.12.2.2, mem.res.private
protected:
    virtual void* do_allocate(size_t, size_t) = 0;
    virtual void do_deallocate(void*, size_t, size_t) = 0;
    virtual bool do_is_equal(memory_resource const &) const _NOEXCEPT = 0;
};

// 23.12.2.3, mem.res.eq
inline _LIBCPP_INLINE_VISIBILITY
bool operator==(memory_resource const & __lhs,
                memory_resource const & __rhs) _NOEXCEPT
{
    return &__lhs == &__rhs || __lhs.is_equal(__rhs);
}

inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(memory_resource const & __lhs,
                memory_resource const & __rhs) _NOEXCEPT
{
    return !(__lhs == __rhs);
}

// 23.12.4, mem.res.global

_LIBCPP_FUNC_VIS
memory_resource * new_delete_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * null_memory_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * get_default_resource() _NOEXCEPT;

_LIBCPP_FUNC_VIS
memory_resource * set_default_resource(memory_resource *) _NOEXCEPT;

// 23.12.3, mem.poly.allocator.class
template <class _ValueType>
class _LIBCPP_TEMPLATE_VIS polymorphic_allocator
{
public:
    typedef _ValueType value_type;

    // 23.12.3.1, mem.poly.allocator.ctor
    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator() _NOEXCEPT
      : __res_(_VSTD::pmr::get_default_resource())
    {}

    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator(memory_resource * __r) _NOEXCEPT
      : __res_(__r)
    {}

    polymorphic_allocator(polymorphic_allocator const &) = default;

    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator(polymorphic_allocator<_Tp> const & __other) _NOEXCEPT
      : __res_(__other.resource())
    {}

    polymorphic_allocator &
    operator=(polymorphic_allocator const &) = delete;

    // 23.12.3.2, mem.poly.allocator.mem
    _LIBCPP_INLINE_VISIBILITY
    _ValueType* allocate(size_t __n) {
        if (__n > __max_size()) {
            __throw_length_error(
                "std::pmr::polymorphic_allocator<T>::allocate(size_t n)"
                " 'n' exceeds maximum supported size");
        }
        return static_cast<_ValueType*>(
            __res_->allocate(__n * sizeof(_ValueType), alignof(_ValueType))
        );
    }

    _LIBCPP_INLINE_VISIBILITY
    void deallocate(_ValueType * __p, size_t __n) _NOEXCEPT {
        _LIBCPP_ASSERT(__n <= __max_size(),
                       "deallocate called for size which exceeds max_size()");
        __res_->deallocate(__p, __n * sizeof(_ValueType), alignof(_ValueType));
    }

    template <class _Tp, class ..._Ts>
    _LIBCPP_INLINE_VISIBILITY
    void construct(_Tp* __p, _Ts &&... __args)
    {
        _VSTD::__user_alloc_construct_impl(
            typename __uses_alloc_ctor<_Tp, memory_resource*, _Ts...>::type(),
            __p, resource(), _VSTD::forward<_Ts>(__args)...
        );
    }

    template <class _T1, class _T2, class ..._Args1, class ..._Args2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2>* __p, piecewise_construct_t,
                   tuple<_Args1...> __x, tuple<_Args2...> __y)
    {
        ::new ((void*)__p) pair<_T1, _T2>(piecewise_construct
          , __transform_tuple(
              typename __uses_alloc_ctor<
                  _T1, memory_resource*, _Args1...
              >::type()
            , _VSTD::move(__x)
            , typename __make_tuple_indices<sizeof...(_Args1)>::type{}
          )
          , __transform_tuple(
              typename __uses_alloc_ctor<
                  _T2, memory_resource*, _Args2...
              >::type()
            , _VSTD::move(__y)
            , typename __make_tuple_indices<sizeof...(_Args2)>::type{}
          )
        );
    }

    template <class _T1, class _T2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2>* __p) {
        construct(__p, piecewise_construct, tuple<>(), tuple<>());
    }

    template <class _T1, class _T2, class _Up, class _Vp>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2> * __p, _Up && __u, _Vp && __v) {
        construct(__p, piecewise_construct
          , _VSTD::forward_as_tuple(_VSTD::forward<_Up>(__u))
          , _VSTD::forward_as_tuple(_VSTD::forward<_Vp>(__v)));
    }

    template <class _T1, class _T2, class _U1, class _U2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> const & __pr) {
        construct(__p, piecewise_construct
            , _VSTD::forward_as_tuple(__pr.first)
            , _VSTD::forward_as_tuple(__pr.second));
    }

    template <class _T1, class _T2, class _U1, class _U2>
    _LIBCPP_INLINE_VISIBILITY
    void construct(pair<_T1, _T2> * __p, pair<_U1, _U2> && __pr){
        construct(__p, piecewise_construct
            , _VSTD::forward_as_tuple(_VSTD::forward<_U1>(__pr.first))
            , _VSTD::forward_as_tuple(_VSTD::forward<_U2>(__pr.second)));
    }

    template <class _Tp>
    _LIBCPP_INLINE_VISIBILITY
    void destroy(_Tp * __p) _NOEXCEPT
        { __p->~_Tp(); }

    _LIBCPP_INLINE_VISIBILITY
    polymorphic_allocator
    select_on_container_copy_construction() const _NOEXCEPT
        { return polymorphic_allocator(); }

    _LIBCPP_INLINE_VISIBILITY
    memory_resource * resource() const _NOEXCEPT
        { return __res_; }

private:
    template <class ..._Args, size_t ..._Idx>
    _LIBCPP_INLINE_VISIBILITY
    tuple<_Args&&...>
    __transform_tuple(integral_constant<int, 0>, tuple<_Args...>&& __t,
                      __tuple_indices<_Idx...>) const
    {
        return _VSTD::forward_as_tuple(_VSTD::get<_Idx>(_VSTD::move(__t))...);
    }

    template <class ..._Args, size_t ..._Idx>
    _LIBCPP_INLINE_VISIBILITY
    tuple<allocator_arg_t const&, memory_resource*, _Args&&...>
    __transform_tuple(integral_constant<int, 1>, tuple<_Args...> && __t,
                      __tuple_indices<_Idx...>) const
    {
        using _Tup = tuple<allocator_arg_t const&, memory_resource*, _Args&&...>;
        return _Tup(allocator_arg, resource(),
                    _VSTD::get<_Idx>(_VSTD::move(__t))...);
    }

    template <class ..._Args, size_t ..._Idx>
    _LIBCPP_INLINE_VISIBILITY
    tuple<_Args&&..., memory_resource*>
    __transform_tuple(integral_constant<int, 2>, tuple<_Args...> && __t,
                      __tuple_indices<_Idx...>) const
    {
        using _Tup = tuple<_Args&&..., memory_resource*>;
        return _Tup(_VSTD::get<_Idx>(_VSTD::move(__t))..., resource());
    }

    _LIBCPP_INLINE_VISIBILITY
    size_t __max_size() const _NOEXCEPT
        { return numeric_limits<size_t>::max() / sizeof(value_type); }

    memory_resource * __res_;
};

// 23.12.3.3, mem.poly.allocator.eq

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY
bool operator==(polymorphic_allocator<_Tp> const & __lhs,
                polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
{
    return *__lhs.resource() == *__rhs.resource();
}

template <class _Tp, class _Up>
inline _LIBCPP_INLINE_VISIBILITY
bool operator!=(polymorphic_allocator<_Tp> const & __lhs,
                polymorphic_allocator<_Up> const & __rhs) _NOEXCEPT
{
    return !(__lhs == __rhs);
}

// 23.12.5, mem.res.pool

// 23.12.5.2, mem.res.pool.options

struct pool_options {
    size_t max_blocks_per_chunk = 0;
    size_t largest_required_pool_block = 0;
};

// 23.12.5.1, mem.res.pool.overview

struct __pool_resource_chunk;

class _LIBCPP_TYPE_VIS unsynchronized_pool_resource : public memory_resource
{
public:
    unsynchronized_pool_resource(const pool_options& __opts, memory_resource* __upstream);

    _LIBCPP_INLINE_VISIBILITY
    unsynchronized_pool_resource()
        : unsynchronized_pool_resource(pool_options(), get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit unsynchronized_pool_resource(memory_resource* __upstream)
        : unsynchronized_pool_resource(pool_options(), __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit unsynchronized_pool_resource(const pool_options& __opts)
        : unsynchronized_pool_resource(__opts, get_default_resource()) {}

    unsynchronized_pool_resource(const unsynchronized_pool_resource&) = delete;

    virtual ~unsynchronized_pool_resource();

    unsynchronized_pool_resource& operator=(const unsynchronized_pool_resource&) = delete;

    void release();

    _LIBCPP_INLINE_VISIBILITY
    memory_resource* upstream_resource() const
        { return __res_; }

    _LIBCPP_INLINE_VISIBILITY
    pool_options options() const
        { return __options_; }

protected:
    void* do_allocate(size_t __bytes, size_t __align);

    void do_deallocate(void* __p, size_t __bytes, size_t __align);

    _LIBCPP_INLINE_VISIBILITY
    bool do_is_equal(const memory_resource& __other) const _NOEXCEPT
        { return this == _VSTD::addressof(__other); }

private:
    memory_resource *__res_;
    __pool_resource_chunk *__chunk_;
    pool_options __options_;
};

class _LIBCPP_TYPE_VIS synchronized_pool_resource : public memory_resource
{
public:
    synchronized_pool_resource(const pool_options& __opts, memory_resource* __upstream)
        : __unsync_(__opts, __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    synchronized_pool_resource()
        : synchronized_pool_resource(pool_options(), get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit synchronized_pool_resource(memory_resource* __upstream)
        : synchronized_pool_resource(pool_options(), __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit synchronized_pool_resource(const pool_options& __opts)
        : synchronized_pool_resource(__opts, get_default_resource()) {}

    synchronized_pool_resource(const synchronized_pool_resource&) = delete;

    virtual ~synchronized_pool_resource();

    synchronized_pool_resource& operator=(const synchronized_pool_resource&) = delete;

    void release() {
#if !defined(_LIBCPP_HAS_NO_THREADS)
        unique_lock<mutex> __lk(__mut_);
#endif
        __unsync_.release();
    }

    _LIBCPP_INLINE_VISIBILITY
    memory_resource* upstream_resource() const
        { return __unsync_.upstream_resource(); }

    _LIBCPP_INLINE_VISIBILITY
    pool_options options() const
        { return __unsync_.options(); }

protected:
    void* do_allocate(size_t __bytes, size_t __align) {
#if !defined(_LIBCPP_HAS_NO_THREADS)
        unique_lock<mutex> __lk(__mut_);
#endif
        return __unsync_.allocate(__bytes, __align);
    }

    void do_deallocate(void* __p, size_t __bytes, size_t __align) {
#if !defined(_LIBCPP_HAS_NO_THREADS)
        unique_lock<mutex> __lk(__mut_);
#endif
        return __unsync_.deallocate(__p, __bytes, __align);
    }

    _LIBCPP_INLINE_VISIBILITY
    bool do_is_equal(const memory_resource& __other) const _NOEXCEPT
        { return this == _VSTD::addressof(__other); }

private:
#if !defined(_LIBCPP_HAS_NO_THREADS)
    mutex __mut_;
#endif
    unsynchronized_pool_resource __unsync_;
};

// 23.12.6, mem.res.monotonic.buffer

struct __monotonic_buffer_header {
    void *__start_;
    __monotonic_buffer_header *__next_;
    size_t __capacity_;
    size_t __alignment_;
    size_t __used_;
};

class _LIBCPP_TYPE_VIS monotonic_buffer_resource : public memory_resource
{
    static const size_t __default_buffer_capacity = 1024;
    static const size_t __default_buffer_alignment = 16;

public:
    _LIBCPP_INLINE_VISIBILITY
    explicit monotonic_buffer_resource(memory_resource* __upstream)
        : monotonic_buffer_resource(nullptr, __default_buffer_capacity, __upstream) {}

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource(size_t __initial_size, memory_resource* __upstream)
        : monotonic_buffer_resource(nullptr, __initial_size, __upstream) {}

    monotonic_buffer_resource(void* __buffer, size_t __buffer_size, memory_resource* __upstream);

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource()
        : monotonic_buffer_resource(get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    explicit monotonic_buffer_resource(size_t __initial_size)
        : monotonic_buffer_resource(__initial_size, get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource(void* __buffer, size_t __buffer_size)
        : monotonic_buffer_resource(__buffer, __buffer_size, get_default_resource()) {}

    _LIBCPP_INLINE_VISIBILITY
    monotonic_buffer_resource(const monotonic_buffer_resource&) = delete;

    virtual ~monotonic_buffer_resource();

    monotonic_buffer_resource& operator=(const monotonic_buffer_resource&) = delete;

    void release();

    _LIBCPP_INLINE_VISIBILITY
    memory_resource* upstream_resource() const
        { return __res_; }

protected:
    void* do_allocate(size_t __bytes, size_t __alignment);

    _LIBCPP_INLINE_VISIBILITY
    void do_deallocate(void*, size_t, size_t)
        {}

    _LIBCPP_INLINE_VISIBILITY
    bool do_is_equal(const memory_resource& __other) const _NOEXCEPT
        { return this == _VSTD::addressof(__other); }

private:
    memory_resource* __res_;
    __monotonic_buffer_header __original_;
};

} // namespace pmr

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif /* _LIBCPP_MEMORY_RESOURCE */
